	.file	"experiment.c"
	.option nopic
	.attribute arch, "rv64i2p0_m2p0_a2p0_f2p0_d2p0_c2p0"
	.attribute unaligned_access, 0
	.attribute stack_align, 16
	.text
	.section	.rodata
	.align	3
.LC0:
	.string	"%d"
	.text
	.align	1
	.globl	main
	.type	main, @function
main:
	addi	sp,sp,-48	//将堆栈指针寄存器sp与立即数(-48)相加，再存入堆栈指针寄存器sp，即sp = sp + (-48)
	sd	ra,40(sp)		//将返回地址寄存器ra中的双字存储到内存地址sp(偏移量40)中
	sd	s0,32(sp)		//将save0号寄存器s0中的双字存储到内存地址sp(偏移量32)中
	addi	s0,sp,48	//将堆栈指针寄存器sp与立即数(48)相加，再存入save0号寄存器s0，即s0 = sp + (48)
	li	a5,27			//伪指令，将常量27加载到函数参数寄存器a5中
	sw	a5,-20(s0)		//将函数参数寄存器a5中的单字存入内存地址s0(偏移量-20)中
	lw	a5,-20(s0)		//将内存地址s0(偏移量-20)中的单字加载到函数参数寄存器a5中
	sw	a5,-24(s0)		//将函数参数寄存器a5中的单字存入内存地址s0(偏移量-24)中
	sw	zero,-28(s0)	//将固定值为零的寄存器zero中的单字存入内存地址s0(偏移量-28)中
	sw	zero,-32(s0)	//将固定值为零的寄存器zero中的单字存入内存地址s0(偏移量-32)中
	j	.L2				//伪指令，程序跳转到L2处继续执行
.L4:
	lw	a4,-24(s0)		//将内存地址s0(偏移量-24)中的单字加载到函数参数寄存器a4中
	sraiw	a5,a4,31	//把函数参数寄存器a4右移31位，空位用a4的最高位填充(算术右移31位)，结果写入a5
	srliw	a5,a5,31	//把函数参数寄存器a5右移31位，空出的位置填入0，结果截为 32 位(逻辑右移31位)，进行有符号扩展后写入函数参数寄存器a5
	addw	a4,a4,a5	//把函数参数寄存器a5加到函数参数寄存器a4上，将结果截断为 32 位，把符号位扩展的结果写入a4,忽略算术溢出
	andi	a4,a4,1		//把符号位扩展的立即数1和函数参数寄存器a4上的值进行位与，结果写入函数参数寄存器a4
	subw	a5,a4,a5	//函数参数寄存器a4减去a5，结果截为 32 位，有符号扩展后写入a5,忽略算术溢出
	sw	a5,-36(s0)		//将函数参数寄存器a5中的单字存入内存地址s0(偏移量-36)中
	lw	a5,-36(s0)		//将内存地址s0(偏移量-36)中的单字加载到函数参数寄存器a5中
	andi	a5,a5,1		//把符号位扩展的立即数1和函数参数寄存器a5上的值进行位与，结果写入函数参数寄存器a5
	sext.w	a5,a5		//把函数参数寄存器a5的低四字节做符号位扩展赋给函数参数寄存器a5
	beq	a5,zero,.L3		//如果函数参数寄存器a5中的值等于0，程序跳转到L3处继续执行
	lw	a4,-28(s0)		//将内存地址s0(偏移量-28)中的单字加载到函数参数寄存器a4中
	lw	a5,-20(s0)		//将内存地址s0(偏移量-20)中的单字加载到函数参数寄存器a5中
	addw	a5,a4,a5	//把函数参数寄存器a4加到函数参数寄存器a5上，将结果截断为 32 位，把符号位扩展的结果写入a5,忽略算术溢出
	sw	a5,-28(s0)		//将函数参数寄存器a5中的单字存入内存地址s0(偏移量-28)中
.L3:
	lw	a5,-24(s0)		//将内存地址s0(偏移量-24)中的单字加载到函数参数寄存器a5中
	sraiw	a5,a5,1		//把函数参数寄存器a5右移1位，空位用a5的最高位填充(算术右移1位)，结果写入a5
	sw	a5,-24(s0)		//将函数参数寄存器a5中的单字存入内存地址s0(偏移量-24)中
	lw	a5,-20(s0)		//将内存地址s0(偏移量-20)中的单字加载到函数参数寄存器a5中
	slliw	a5,a5,1		//把函数参数寄存器a5左移1位，空出的位置填入0，结果截为 32 位(逻辑左移1位)，进行有符号扩展后写入函数参数寄存器a5
	sw	a5,-20(s0)		//将函数参数寄存器a5中的单字存入内存地址s0(偏移量-20)中
	lw	a5,-32(s0)		//将内存地址s0(偏移量-32)中的单字加载到函数参数寄存器a5中
	addiw	a5,a5,1		//将立即数1加到函数参数寄存器a5上，将结果截断为 32 位，把符号位扩展的结果写入a5,忽略算术溢出
	sw	a5,-32(s0)		//将函数参数寄存器a5中的单字存入内存地址s0(偏移量-32)中
.L2:
	lw	a5,-32(s0)		//将内存地址s0(偏移量-32)中的单字加载到函数参数寄存器a5中
	sext.w	a4,a5		//把函数参数寄存器a5的低四字节做符号位扩展赋给函数参数寄存器a4
	li	a5,7			//伪指令，将常量7加载到函数参数寄存器a5中
	ble	a4,a5,.L4		//如果函数参数寄存器a4中的值小于等于函数参数寄存器a5中的值，程序跳转到L4处继续执行
	lw	a5,-28(s0)		//将内存地址s0(偏移量-28)中的单字加载到函数参数寄存器a5中
	mv	a1,a5			//伪指令，把函数参数寄存器a5中的值复制到a1中
	lui	a5,%hi(.LC0)	//计算LCO地址，取高20位存入函数参数寄存器a5中
	addi	a0,a5,%lo(.LC0)//将函数参数寄存器a5与LCO地址的低12位相加，结果存入a0中
	call	printf		//调用printf函数，输出结果
	li	a5,0			//伪指令，将常量0加载到a5中
	mv	a0,a5			//伪指令，把a5中的值复制到a0中
	ld	ra,40(sp)		//将内存地址s0(偏移量40)中的双字加载到返回地址寄存器ra中
	ld	s0,32(sp)		//将内存地址s0(偏移量32)中的单字加载到save0号寄存器s0中
	addi	sp,sp,48	//将堆栈指针寄存器sp与立即数48相加，结果存入堆栈指针寄存器sp中
	jr	ra				//伪指令，程序跳转到ra寄存器中的地址
	.size	main, .-main
	.ident	"GCC: (GNU) 9.2.0"
