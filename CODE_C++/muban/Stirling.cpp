//第一类斯特林数：
//给出 n  个不同的数，选出 m  个非空圆排列，问有多少种方案？
/*
原理：
定义s1[i][j]表示 i  个不同数形成 j 个圆排列的方案数。这个状态很明显可以由两个状态转移过来：
第一个：i − 1  个数形成 j − 1 个圆排列，那么新加入的数只需要新形成一个圆排列就可以了。
第二个：i − 1  个数形成 j 个圆排列，那么新的数必须加入到原来的 j 个排列中去。显然加入到原来的 i − 1 个数的任意一个数的左边都是不同的。
那么总的方案数就是s1[i][j]=s1[i-1][j-1]+s1[i-1][j]*(i-1)。
*/

typedef long long ll;

const int N = 105;
ll s1[N][N];
void stirling1()
{
    s1[1][1] = 1;
    for (int i = 2; i <= n; i++)
    {
        for (int j = 1; j <= i; j++)
        {
            s1[i][j] = s1[i - 1][j] * (i - 1) + s1[i - 1][j - 1];
        }
    }
}

//第二类斯特林数：
//给定 n  个不同的数，将这 n 个数分成 m  个非空的集合，问有多少种不同的方案？

/*
原理
和第一类斯特林数一样，s2[i][j]表示将 i  个数分成 j  个集合，也有两种情况：
第一个：i − 1  个数分成了 j − 1  个集合，那么新的数只需要放入新的几个就可以了。
第二个：i − 1  个数分成了 j 个集合，那么新的那个数就必须放入这 j  个集合任意一个。
*/

const int N = 105;
ll s2[N][N];
void stirling2()
{
    s2[1][1] = 1;
    for (int i = 2; i <= n; i++)
    {
        for (int j = 1; j <= i; j++)
        {
            s2[i][j] = s2[i - 1][j] * j + s2[i - 1][j - 1];
        }
    }
}